// Date: 2025-12-30T01:08:45.4657261-06:00
// begin import shdSandSimCommon.fsh.__shady_export
// begin import shdMaths.fsh.__shady_export
#region Converters
int float_to_byte(float x) {
    return int(floor(clamp(x, 0.0, 1.0) * 255.0 + 0.5));
}
float byte_to_float(int x) {
    return clamp(float(x), 0.0, 255.0) / 255.0;
}
#endregion
int imod(int x, int y) {
    return x - y * int(floor(float(x) / float(y)));
}
#region Bitwise Ops
int bit_shift_left(int x, int n) {
    return int(float(x) * pow(2.0, float(n)));
}
int bit_shift_right(int x, int n) {
    return int(floor(float(x) / pow(2.0, float(n))));
}
int bitwise_and(int x, int mask) {
    return x - (x / (mask + 1)) * (mask + 1); // equivalent to x % (mask + 1) if mask is a power-of-two minus 1
}
int bitwise_and_of_pow2(int x, int pow2) {
    return imod(x, pow2);
}
int bitwise_or(int x, int y) {
    int result = 0;
    for (int i = 0; i < 8; ++i) {
        int bit = int(pow(2.0, float(i)));
        if (mod(float(x), float(2 * bit)) >= float(bit) ||
            mod(float(y), float(2 * bit)) >= float(bit)) {
            result += bit;
        }
    }
    return result;
}
int bitwise_xor(int x, int y) {
    int result = 0;
    for (int i = 0; i < 8; ++i) {
        int bit = int(pow(2.0, float(i)));
        bool a = mod(float(x), float(2 * bit)) >= float(bit);
        bool b = mod(float(y), float(2 * bit)) >= float(bit);
        if (a != b) {
            result += bit;
        }
    }
    return result;
}
int bitwise_not(int x, int bit_count) {
    return int(pow(2.0, float(bit_count)) - 1.0) - x;
}
#endregion
int clamp(int v, int lower, int upper) {
	return (v < lower) ? lower : ((v > upper) ? upper : v);
}
float abs_float(float x) {
    return x < 0.0 ? -x : x;
}
int abs_int(int x) {
    return x < 0 ? -x : x;
}
int sign_int(int x) {
    return (x > 0) ? 1 : ((x < 0) ? -1 : 0);
}
float sign_float(float x) {
    return (x > 0.0) ? 1.0 : ((x < 0.0) ? -1.0 : 0.0);
}
#region Random
float rand(vec2 p, float seed) {
    vec2 K1 = vec2(23.14069263277926, 2.665144142690225);
    p += vec2(seed, seed * 1.61803); // Golden twist
    return fract(cos(dot(p, K1)) * 12345.6789);
}
int irand(int max_val, vec2 p, float seed) {
    return int(floor(rand(p, seed) * float(max_val)));
}
bool chance(float probability, vec2 p, float seed) {
	if (probability >= 1.0) {
		return true;
	}
    return rand(p, seed) < probability;
}
float rand_range(float min_val, float max_val, vec2 p, float seed) {
    return mix(min_val, max_val, rand(p, seed));
}
int irand_range(int min_val, int max_val, vec2 p, float seed) {
    return min_val + irand(max_val - min_val, p, seed);
}
int round(float x) {
    return int(floor(x + 0.5));
}
#endregion
// end import shdMaths.fsh.__shady_export
#region Data Structures
struct ElementStaticData {
	int id;						// The ID of the element
	int state_of_matter;        // 0 = empty, 1 = gas, 2 = liquid, 3 = solid
    float gravity_force;        // Gravity strength per frame (e.g., 0.25 = slow fall)
    float max_vel_x;            // Maximum horizontal velocity
    float max_vel_y;            // Maximum vertical velocity
	bool can_slip;               // 1 = can attempt diagonal fallback
    float x_slip_search_range;   // Horizontal movement range
    float y_slip_search_range;   // Vertical movement range (in gravity direction)
	float wake_chance; // Chance to wake up from nearby movement (0.0 = inert, 1.0 = always wake)
	float stickiness_chance;    // Preference to clump (higher = more sticky)
	float bounce_chance;        // Chance to bounce on hard landing (0.0 - 1.0)
	float bounce_dampening_multiplier;     // Fraction of velocity retained after a bounce (0.0 = no bounce, 1.0 = perfect)
	float airborne_vel_decay_chance;    // Chance for Velocity decay while airborn (adds better random movements)
	float friction_vel_decay_chance;    // Chance for Velocity decay while grounded (adds better random movements)
    float mass;                   // Affects momentum transfer
    bool can_ignite;                 // True if it can catch fire
    float temperature_decay;           //chance to disperse heat or cold
	float temperature_spread_chance;   //chance of adopting temperature from neighbor
    float explosion_resistance;       // Resistance to explosion
    float explosion_radius;       // Radius if it explodes
    float custom_event_chance; // Optional: triggers a special effect, defined in the element macro
    int replace_count;          // Number of element types this can move into
    int replace_ids[4];         // Element IDs it can replace
};
struct ElementDynamicData {
    int id;
	ElementStaticData static_data;
    vec2 vel;
    int x_dir;
    int y_dir;
    int x_speed;
    int y_speed;
    bool is_moving;
	bool unused_movement_bool;
};
#endregion
#region Element IDs Enum
#define ELEM_ID_EMPTY 0
#define ELEM_ID_WATER 100
#define ELEM_ID_SAND 255
#endregion
#region Getter Functions
int elem_get_index(vec4 px) {
    return int(floor(px.r * 255.0 + 0.5));
}
#endregion
#region Element Static Data
ElementStaticData get_element_static_data(int id) {
    ElementStaticData elem_static_data;
	if (id == ELEM_ID_SAND) {
// begin import ElemSand.fsh.__shady_macro_DefineElementStaticData
	int sand_replace_ids[4];
	sand_replace_ids[0] = ELEM_ID_WATER;
	sand_replace_ids[1] = 0;
	sand_replace_ids[2] = 0;
	sand_replace_ids[3] = 0;
	
	
	ElementStaticData elem_static_data = ElementStaticData(
	    ELEM_ID_SAND,       // id
	    3,                  // state_of_matter (solid)

	    // === Gravity & Movement ===
	    1.0,                // gravity_force
	    2.0,                // max_vel_x
	    2.0,                // max_vel_y

	    true,               // can_slip
	    1.0,                // x_slip_search_range
	    1.0,                // y_slip_search_range
		
		1.0,                // wake_chance

	    0.0,                // stickiness_chance

	    0.1,                // bounce_chance
	    0.4,                // bounce_dampening_multiplier (moderate energy loss)

	    // === Velocity Decay ===
	    0.35,                // airborne_vel_decay_chance (slow air decay)
	    0.65,                // friction_vel_decay_chance (stronger on ground)

	    // === Physical ===
	    150.0,              // mass

	    // === Heat and Flammability ===
	    false,              // can_ignite
	    0.0,                // temperature_decay
	    0.0,                // temperature_spread_chance

	    // === Explosive Properties ===
	    1.0,                // explosion_resistance
	    0.0,                // explosion_radius

	    // === Lifecycle Control ===
	    0.0,                // custom_event_chance (none)

	    // === Replacement Rules ===
	    1,                  // replace_count
	    sand_replace_ids    // replace_ids[4]
	);


	
// end import ElemSand.fsh.__shady_macro_DefineElementStaticData
		return elem_static_data;
    }
	return elem_static_data;
}
#endregion
#region Dynamic Data
ElementDynamicData ununpack_elem_dynamic_data(vec4 pixel) {
    ElementDynamicData elem_dynamic_data;
    elem_dynamic_data.id = elem_get_index(pixel);
	elem_dynamic_data.static_data = get_element_static_data(elem_dynamic_data.id);
    int g = float_to_byte(pixel.g);
    elem_dynamic_data.y_dir               = bitwise_and(bit_shift_right(g, 7), 1);
    elem_dynamic_data.y_speed             = bitwise_and(bit_shift_right(g, 5), 3);
    elem_dynamic_data.x_dir               = bitwise_and(bit_shift_right(g, 4), 1);
    elem_dynamic_data.x_speed             = bitwise_and(bit_shift_right(g, 2), 3);
    elem_dynamic_data.is_moving            = bool(bitwise_and(bit_shift_right(g, 1), 1));
    elem_dynamic_data.unused_movement_bool = bool(bitwise_and(bit_shift_right(g, 0), 1));
    float x_norm = float(elem_dynamic_data.x_speed) / 3.0;
    float y_norm = float(elem_dynamic_data.y_speed) / 3.0;
    float x_signed = x_norm * (elem_dynamic_data.x_dir == 0 ? 1.0 : -1.0);
    float y_signed = y_norm * (elem_dynamic_data.y_dir == 0 ? 1.0 : -1.0);
    elem_dynamic_data.vel = vec2(
        x_signed * float(elem_dynamic_data.static_data.max_vel_x),
        y_signed * float(elem_dynamic_data.static_data.max_vel_y)
    );
    return elem_dynamic_data;
}
vec4 pack_elem_dynamic_data(in ElementDynamicData elem_dynamic_data) {
    int g = 0;
	int x_speed = int(round(clamp(abs(elem_dynamic_data.vel.x) / float(elem_dynamic_data.static_data.max_vel_x), 0.0, 1.0) * 3.0));
	int y_speed = int(round(clamp(abs(elem_dynamic_data.vel.y) / float(elem_dynamic_data.static_data.max_vel_y), 0.0, 1.0) * 3.0));
    int x_dir = elem_dynamic_data.vel.x >= 0.0 ? 0 : 1;
    int y_dir = elem_dynamic_data.vel.y >= 0.0 ? 0 : 1;
    g = bitwise_or(g, bit_shift_left(clamp(y_dir   , 0, 1), 7));
    g = bitwise_or(g, bit_shift_left(clamp(y_speed , 0, 3), 5));
    g = bitwise_or(g, bit_shift_left(clamp(x_dir   , 0, 1), 4));
    g = bitwise_or(g, bit_shift_left(clamp(x_speed , 0, 3), 2));
    g = (elem_dynamic_data.is_moving)            ? bitwise_or(g, bit_shift_left(1, 1)) : g;
	g = (elem_dynamic_data.unused_movement_bool) ? bitwise_or(g, bit_shift_left(1, 0)) : g;
    float g_float = byte_to_float(g);
    float r_float = byte_to_float(elem_dynamic_data.id);
    return vec4(r_float, g_float, 0.0, 1.0);
}
#endregion
#region is_* functions
bool elem_is_solid(ElementStaticData elem) {
    return elem.state_of_matter == 3;
}
bool elem_is_liquid(ElementStaticData elem) {
    return elem.state_of_matter == 2;
}
bool elem_is_gas(ElementStaticData elem) {
    return elem.state_of_matter == 1;
}
bool elem_is_empty(ElementStaticData elem) {
    return elem.state_of_matter == 0 || elem.id == ELEM_ID_EMPTY;
}
bool cell_is_solid(vec4 pixel) {
	return get_element_static_data(elem_get_index(pixel)).state_of_matter == 3;
}
bool cell_is_liquid(vec4 pixel) {
    return get_element_static_data(elem_get_index(pixel)).state_of_matter == 2;
}
bool cell_is_gas(vec4 pixel) {
    return get_element_static_data(elem_get_index(pixel)).state_of_matter == 1;
}
bool cell_is_empty(vec4 pixel) {
    return elem_get_index(pixel) == ELEM_ID_EMPTY || get_element_static_data(elem_get_index(pixel)).state_of_matter == 0;
}
#endregion
bool element_can_replace(ElementStaticData src, ElementStaticData dst) {
    if (dst.state_of_matter == 3) {
        return false;
    }
    if (dst.state_of_matter <= src.state_of_matter) {
        return true;
    }
    for (int i = 0; i < src.replace_count; ++i) {
        if (src.replace_ids[i] == dst.id) {
            return true;
        }
    }
    return false;
}
vec2 vel_to_rg(vec2 vel) {
    return (vel + 128.0) / 255.0;
}
vec2 rg_to_vel(vec2 rg) {
    return vec2(floor(rg * 255.0 + 0.5)) - vec2(128.0);
}
vec2 rand_round_vel(vec2 velocity, vec2 texcoord, float seed) {
    vec2 rounded;
    float ax = abs(fract(velocity.x));
    float ay = abs(fract(velocity.y));
    float rand_x = rand(texcoord, seed);
    float rand_y = rand(texcoord, seed + 1.0);
    rounded.x = floor(velocity.x + (rand_x < ax ? 1.0 : 0.0));
    rounded.y = floor(velocity.y + (rand_y < ay ? 1.0 : 0.0));
    return rounded;
}
// end import shdSandSimCommon.fsh.__shady_export

#define OFFSET_RADIUS 3


varying vec2 v_vTexcoord;
varying vec4 v_vColour;

uniform vec2 u_texel_size;
uniform sampler2D gm_SecondaryTexture; // velocity surface (RG)

// Score movement priority by proximity
float compute_claim_score(vec2 offset) {
    return dot(offset, offset);
}

void main() {
    vec4 self_pixel = texture2D(gm_BaseTexture, v_vTexcoord);
    ElementDynamicData elem_dynamic_data = ununpack_elem_dynamic_data(self_pixel);
	
	float best_score = 99999.0;
    vec2 best_offset = vec2(0);
	
    for (int oy = -OFFSET_RADIUS; oy <= OFFSET_RADIUS; ++oy) {
        for (int ox = -OFFSET_RADIUS; ox <= OFFSET_RADIUS; ++ox) {
            
			//skip self
			if (ox == 0 && oy == 0) continue;
			
            vec2 offset = vec2(float(ox), float(oy));
            vec2 neighbor_uv = v_vTexcoord + offset * u_texel_size;
			
			//skip out of bounds
            if (neighbor_uv.x < 0.0 || neighbor_uv.y < 0.0 ||
                neighbor_uv.x > 1.0 || neighbor_uv.y > 1.0) continue;
			
			
            vec4 vel_px   = texture2D(gm_SecondaryTexture, neighbor_uv);
			vec4 elem_px  = texture2D(gm_BaseTexture,      neighbor_uv);
			
			ElementDynamicData neighbor_elem_dynamic_data = ununpack_elem_dynamic_data(elem_px);
			
			//skip pixels which arent moving
			if (!neighbor_elem_dynamic_data.is_moving) continue;
			
            vec2 vel = rg_to_vel(vel_px.rg);
			
            // Is the neighbor trying to move into us?
            vec2 offset_dir = vec2(ox, oy);
			
			if (all(equal(-vel, offset_dir))) {
			    // === Permission check (custom element logic goes here)
			    bool accepted = false;
				
				//Use a while loop just so we can break out when we find a match and skip everything else
				while(true){
// begin import ElemSand.fsh.__shady_macro_ACCEPT
	if (elem_dynamic_data.id == ELEM_ID_SAND) {
		
		//currently sand doesnt accept anything else
		accepted = false;
		
		break;
	}
// end import ElemSand.fsh.__shady_macro_ACCEPT
					
					accepted = true;
					break;
				}
				
			    if (accepted) {
			        float score = compute_claim_score(offset);
			        if (score < best_score) {
			            best_score = score;
			            best_offset = offset_dir;
			        }
			    }
			}


        }
    }

    gl_FragColor = vec4(vel_to_rg(best_offset), 0.0, 1.0);
}
