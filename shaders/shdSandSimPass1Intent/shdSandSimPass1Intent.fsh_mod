// Date: 2025-06-19T13:09:46.0181117-05:00
// begin import shdSandSimCommon.fsh.__shady_export
// begin import shdMaths.fsh.__shady_export
int float_to_byte(float x) {
    return int(floor(clamp(x, 0.0, 1.0) * 255.0 + 0.5));
}
float byte_to_float(int x) {
    return clamp(float(x), 0.0, 255.0) / 255.0;
}
int imod(int x, int y) {
    return x - y * int(floor(float(x) / float(y)));
}
int bit_shift_left(int x, int n) {
    return int(float(x) * pow(2.0, float(n)));
}
int bit_shift_right(int x, int n) {
    return int(floor(float(x) / pow(2.0, float(n))));
}
int bitwise_and(int x, int mask) {
    return x - (x / (mask + 1)) * (mask + 1); // equivalent to x % (mask + 1) if mask is a power-of-two minus 1
}
int bitwise_and_of_pow2(int x, int pow2) {
    return imod(x, pow2);
}
int bitwise_or(int x, int y) {
    int result = 0;
    for (int i = 0; i < 8; ++i) {
        int bit = int(pow(2.0, float(i)));
        if (mod(float(x), float(2 * bit)) >= float(bit) ||
            mod(float(y), float(2 * bit)) >= float(bit)) {
            result += bit;
        }
    }
    return result;
}
int bitwise_xor(int x, int y) {
    int result = 0;
    for (int i = 0; i < 8; ++i) {
        int bit = int(pow(2.0, float(i)));
        bool a = mod(float(x), float(2 * bit)) >= float(bit);
        bool b = mod(float(y), float(2 * bit)) >= float(bit);
        if (a != b) {
            result += bit;
        }
    }
    return result;
}
int bitwise_not(int x, int bit_count) {
    return int(pow(2.0, float(bit_count)) - 1.0) - x;
}
int clamp(int v, int lower, int upper) {
	return (v < lower) ? lower : ((v > upper) ? upper : v);
}
float abs_float(float x) {
    return x < 0.0 ? -x : x;
}
int abs_int(int x) {
    return x < 0 ? -x : x;
}
float rand(vec2 p, float seed) {
    vec2 K1 = vec2(23.14069263277926, 2.665144142690225);
    p += vec2(seed, seed * 1.61803); // Golden twist
    return fract(cos(dot(p, K1)) * 12345.6789);
}
int irand(int max_val, vec2 p, float seed) {
    return int(floor(rand(p, seed) * float(max_val)));
}
bool chance(float probability, vec2 p, float seed) {
    return rand(p, seed) < probability;
}
float rand_range(float min_val, float max_val, vec2 p, float seed) {
    return mix(min_val, max_val, rand(p, seed));
}
int irand_range(int min_val, int max_val, vec2 p, float seed) {
    return min_val + irand(max_val - min_val + 1, p, seed);
}
int round(float x) {
    return int(floor(x + 0.5));
}
// end import shdMaths.fsh.__shady_export
struct ElemMeta {
    int id;
	ivec2 vel;
    int x_dir;
    int y_dir;
    int x_speed;
    int y_speed;
};
#region Element IDs Enum
#define Elem_Empty 0
#define Elem_Water 100
#define Elem_Sand 255
#endregion
#region Elem getter functions
int elem_get_index(vec4 px) {
    return int(floor(px.r * 255.0 + 0.5));
}
ivec2 elem_get_velocity(vec4 pixel) {
    int g = float_to_byte(pixel.g);
    int y_dir   = bitwise_and(bit_shift_right(g, 7), 1);
    int y_speed = bitwise_and(bit_shift_right(g, 6), 3);
    int x_dir   = bitwise_and(bit_shift_right(g, 4), 1);
	int x_speed = bitwise_and(bit_shift_right(g, 2), 3);
    int vx = (x_dir == 1) ? x_speed : -x_speed;
    int vy = (y_dir == 1) ? y_speed : -y_speed;
    return ivec2(vx, vy);
}
int elem_get_xdir(vec4 pixel) {
    return bitwise_and(bit_shift_right(float_to_byte(pixel.g), 1), 1);
}
int elem_get_ydir(vec4 pixel) {
    return bitwise_and(bit_shift_right(float_to_byte(pixel.g), 5), 1);
}
int elem_get_xspeed(vec4 pixel) {
    return bitwise_and(bit_shift_right(float_to_byte(pixel.g), 2), 3);
}
int elem_get_yspeed(vec4 pixel) {
    return bitwise_and(bit_shift_right(float_to_byte(pixel.g), 6), 3);
}
#endregion
void unpack_pixel(vec4 pixel, inout ElemMeta metadata) {
    metadata.id = elem_get_index(pixel);
    int g = float_to_byte(pixel.g);
    metadata.y_dir   = bitwise_and(bit_shift_right(g, 7), 1);
    metadata.y_speed = bitwise_and(bit_shift_right(g, 5), 3);
    metadata.x_dir   = bitwise_and(bit_shift_right(g, 4), 1);
    metadata.x_speed = bitwise_and(bit_shift_right(g, 2), 3);
    metadata.vel = ivec2(
        (metadata.x_dir == 1) ? metadata.x_speed : -metadata.x_speed,
        (metadata.y_dir == 1) ? metadata.y_speed : -metadata.y_speed
    );
}
vec4 pack_pixel(in ElemMeta meta) {
    int g = 0;
    g = bitwise_or(g, bit_shift_left(clamp(meta.y_dir  , 0, 1), 7));
    g = bitwise_or(g, bit_shift_left(clamp(meta.y_speed, 0, 3), 5));
    g = bitwise_or(g, bit_shift_left(clamp(meta.x_dir  , 0, 1), 4));
    g = bitwise_or(g, bit_shift_left(clamp(meta.x_speed, 0, 3), 2));
    float g_float = byte_to_float(g);
    float r_float = byte_to_float(meta.id); // assuming ID lives in red
    return vec4(r_float, g_float, 0.0, 1.0);
}
vec2 vel_to_rg(ivec2 vel) {
    return (vec2(vel) + 128.0) / 255.0;
}
ivec2 rg_to_vel(vec2 rg) {
    return ivec2(floor(rg * 255.0 + 0.5)) - 128;
}
// end import shdSandSimCommon.fsh.__shady_export

varying vec2 v_vTexcoord;
varying vec4 v_vColour;

uniform vec2 u_texel_size;
uniform float u_frame;


void main() {
    ElemMeta metadata;
	vec4 self_pixel = texture2D(gm_BaseTexture, v_vTexcoord);
    unpack_pixel(self_pixel, metadata);
	
    //Use a while loop just so we can break out when we find a match and skip everything else
	while(true){
// begin import ElemSand.fsh.__shady_macro_INTENT
if (metadata.id == Elem_Sand) {
    // 1. Try to reuse falling motion
    if (metadata.vel.x > 0 || metadata.vel.y > 0) {
		// Air resistance for horz velocity
		if (abs_int(metadata.vel.x) == 3) {
		    if (rand(v_vTexcoord + vec2(1.234, 4.567), u_frame) < 0.2) {
		        int x_dir = (metadata.vel.x >= 0) ? 1 : -1;
		        metadata.vel.x = 2 * x_dir;
		        metadata.x_speed = 2;
		        metadata.x_dir = (x_dir > 0) ? 1 : 0;
		    }
		}

		
        vec2 fall_uv = v_vTexcoord + vec2(metadata.vel) * u_texel_size;
        vec4 fall_px = texture2D(gm_BaseTexture, fall_uv);
        int fall_id = elem_get_index(fall_px);

        if (fall_id == 0) {
            // Random chance to increase speed (simulate gravity)
            if (chance(0.1, v_vTexcoord, u_frame)) {
                metadata.vel.y = clamp(metadata.vel.y + 1, 0, 3);
            }
            break;
        }
    }
	
    // 2. Fallback classic sand behavior
    vec2 down_uv = v_vTexcoord + vec2(0.0, u_texel_size.y);
    vec4 down_px = texture2D(gm_BaseTexture, down_uv);
    int down_id = elem_get_index(down_px);

    if (down_id == 0) {
        metadata.vel = ivec2(0, 1);
    } else {
        // Diagonal fallback
        int dx = (rand(v_vTexcoord, u_frame) < 0.5) ? -1 : 1;

        vec2 diag1_uv = v_vTexcoord + vec2(float(dx), 1.0) * u_texel_size;
        vec4 diag1_px = texture2D(gm_BaseTexture, diag1_uv);
        int diag1_id = elem_get_index(diag1_px);

        if (diag1_id == 0) {
            metadata.vel = ivec2(dx, 1);
        } else {
            dx = -dx;
            vec2 diag2_uv = v_vTexcoord + vec2(float(dx), 1.0) * u_texel_size;
            vec4 diag2_px = texture2D(gm_BaseTexture, diag2_uv);
            int diag2_id = elem_get_index(diag2_px);

            if (diag2_id == 0) {
                metadata.vel = ivec2(dx, 1);
            }
        }
    }

    break;
}
// end import ElemSand.fsh.__shady_macro_INTENT
		
		
		
		break;
	}
    
	// Default to no movement
	gl_FragColor = vec4(vel_to_rg(metadata.vel), 0.0, 1.0);
}
